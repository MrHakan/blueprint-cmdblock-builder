<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blueprint Command Builder | Command Block Assembler</title>
    <link rel="icon" href="https://styles.redditmedia.com/t5_6aviyc/styles/profileIcon_msenduashsw81.jpg"
        type="image/png">
    <link rel="stylesheet" href="./styles/blueprint.css">
    <link rel="stylesheet" href="./styles/minecraft-theme.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="./scripts/sync-manager.js"></script>
</head>

<body>
    <div class="blueprint-container">
        <!-- Toolbar -->
        <header class="toolbar">
            <h1>Blueprint Command Builder</h1>
            <div class="toolbar-buttons">
                <button class="toolbar-btn" onclick="blueprintEditor.saveGraph()">
                    <i class="fas fa-save"></i> Save
                </button>
                <button class="toolbar-btn" onclick="blueprintEditor.loadGraph()">
                    <i class="fas fa-folder-open"></i> Load
                </button>
                <button class="toolbar-btn" onclick="blueprintEditor.clearCanvas()">
                    <i class="fas fa-trash"></i> Clear
                </button>
                <button class="toolbar-btn primary" onclick="blueprintEditor.exportCommands()">
                    <i class="fas fa-file-export"></i> Export to CBA
                </button>
            </div>
        </header>

        <!-- Sidebar: Node Palette -->
        <aside class="node-palette" id="nodePalette">
            <div class="palette-header">Node Library</div>
            <input type="text" class="palette-search" placeholder="Search nodes..." id="nodeSearch">
            <div id="paletteContent">
                <!-- Palette categories will be dynamically generated -->
            </div>
        </aside>

        <!-- Canvas Area -->
        <main class="canvas-container" id="canvasContainer">
            <div class="canvas-grid" id="canvasGrid"></div>
            <svg id="connectionsSvg">
                <defs>
                    <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6"
                        orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" fill="#fff" />
                    </marker>
                </defs>
            </svg>
            <div id="nodeLayer"></div>
            <div class="minimap" id="minimap"></div>
        </main>

        <!-- Sidebar: Properties -->
        <aside class="properties-panel" id="propertiesPanel">
            <div class="properties-header">
                <i class="fas fa-sliders-h"></i> Node Properties
            </div>
            <div id="propertiesContent">
                <div class="empty-state">Select a node to edit properties</div>
            </div>
        </aside>

        <!-- Output Panel -->
        <footer class="output-panel">
            <div class="output-tabs">
                <div class="output-tab active" data-tab="preview">Generated Commands</div>
                <div class="output-tab" data-tab="log">Compiler Output</div>
            </div>
            <div class="output-content">
                <textarea id="commandOutput" readonly
                    placeholder="Your command graph will be compiled here..."></textarea>
                <div id="compilerLog" class="compiler-log" style="display: none;">
                    <div class="log-entry info">Compiler ready. Add nodes to begin.</div>
                </div>
            </div>
            <div class="sync-status" id="syncStatus">
                <span class="sync-indicator synced"></span>
                <span>Synced with CBA</span>
            </div>
        </footer>
    </div>

    <!-- Navigation to CBA -->
    <a href="./cba" class="cba-link" id="cbaLink" title="Open Command Block Assembler">
        <i class="fas fa-terminal"></i>
        <span>Open in CBA</span>
    </a>

    <!-- Scripts -->
    <script src="./scripts/registry/Registry.js"></script>
    <script src="./scripts/blueprint/asset-data.js"></script>
    <script src="./scripts/blueprint/nodes.js"></script>
    <script src="./scripts/blueprint/compiler.js"></script>
    <script src="./scripts/blueprint/node-editor.js"></script>
    <script>
        // Initialize the editor when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.blueprintEditor = new BlueprintEditor('canvasContainer');

            // Auto-load saved graph from localStorage
            const savedGraph = localStorage.getItem('blueprint_graph');
            if (savedGraph) {
                try {
                    blueprintEditor.restoreGraph(JSON.parse(savedGraph));
                    console.log('[Blueprint] Auto-loaded saved graph');
                } catch (e) {
                    console.error('[Blueprint] Failed to auto-load graph:', e);
                }
            }

            // Tab switching functionality
            const tabs = document.querySelectorAll('.output-tab');
            const commandOutput = document.getElementById('commandOutput');
            const compilerLog = document.getElementById('compilerLog');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    const tabName = tab.dataset.tab;
                    if (tabName === 'preview') {
                        commandOutput.style.display = 'block';
                        compilerLog.style.display = 'none';
                    } else {
                        commandOutput.style.display = 'none';
                        compilerLog.style.display = 'block';
                    }
                });
            });
        });

        // Global function to log compiler messages
        function logCompiler(message, type = 'info') {
            const log = document.getElementById('compilerLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;

            // Keep only last 100 entries
            while (log.children.length > 100) {
                log.removeChild(log.firstChild);
            }
        }

        // Auto-sync commands to CBA via SyncManager
        function syncToCBA(commands) {
            // Get graph data for sync
            let graphData = null;
            if (window.blueprintEditor) {
                graphData = {
                    nodes: blueprintEditor.nodes.map((n, idx) => ({
                        id: idx,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        data: n.data
                    })),
                    connections: blueprintEditor.connections.map(c => ({
                        fromNodeId: blueprintEditor.nodes.indexOf(c.fromNode),
                        fromPinName: c.fromPin.name,
                        toNodeId: blueprintEditor.nodes.indexOf(c.toNode),
                        toPinName: c.toPin.name,
                        type: c.type
                    })),
                    nodeCount: blueprintEditor.nodes.length,
                    connectionCount: blueprintEditor.connections.length
                };
            }

            // Use SyncManager for cross-tab sync
            if (window.syncManager) {
                syncManager.updateGraph(graphData, commands);
            }

            // Also update old format for backward compatibility
            let cbData = JSON.parse(localStorage.getItem('command_blocks')) || {};
            cbData.myInput = commands;
            if (graphData) {
                cbData.blueprintGraph = graphData;
            }
            localStorage.setItem('command_blocks', JSON.stringify(cbData));

            const status = document.getElementById('syncStatus');
            const indicator = status.querySelector('.sync-indicator');

            indicator.classList.remove('synced');
            indicator.classList.add('syncing');

            setTimeout(() => {
                indicator.classList.remove('syncing');
                indicator.classList.add('synced');
            }, 500);

            logCompiler(`Synced ${commands.split('\n').filter(l => l.trim()).length} commands to CBA`, 'success');
        }
    </script>

    <style>
        /* Additional styles for new features */
        .compiler-log {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            background: #1a1a1a;
            height: 100%;
            overflow-y: auto;
            padding: 10px;
        }

        .log-entry {
            padding: 4px 8px;
            border-left: 3px solid #444;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.02);
        }

        .log-entry.info {
            border-color: #4a9eff;
        }

        .log-entry.success {
            border-color: #4caf50;
        }

        .log-entry.warning {
            border-color: #ffc107;
        }

        .log-entry.error {
            border-color: #f44336;
        }

        .log-time {
            color: #666;
            margin-right: 8px;
        }

        .sync-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            font-size: 11px;
            color: #888;
        }

        .sync-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .sync-indicator.synced {
            background: #4caf50;
        }

        .sync-indicator.syncing {
            background: #ffc107;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .cba-link {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #4caf50, #2e7d32);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .cba-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }

        .cba-link i {
            font-size: 16px;
        }
    </style>

    <script>
        // =============================================
        // SEAMLESS CBA-BLUEPRINT SYNC LISTENER
        // =============================================

        // Listen for changes from CBA
        function initBlueprintSync() {
            if (!window.syncManager) {
                console.warn('[Blueprint Sync] SyncManager not available');
                return;
            }

            // Subscribe to sync updates from CBA
            syncManager.subscribe((state, source) => {
                if (source === 'external' && state && state.lastEditor === 'cba') {
                    console.log('[Blueprint Sync] Received update from CBA');
                    // CBA made changes - show notification
                    showSyncNotification('Commands updated from CBA');

                    // Update command output display
                    const output = document.getElementById('commandOutput');
                    if (output && state.commands) {
                        output.value = state.commands;
                    }
                }
            });
        }

        // Show sync notification
        function showSyncNotification(message) {
            const status = document.getElementById('syncStatus');
            if (status) {
                const indicator = status.querySelector('.sync-indicator');
                if (indicator) {
                    indicator.classList.add('syncing');
                    setTimeout(() => {
                        indicator.classList.remove('syncing');
                        indicator.classList.add('synced');
                    }, 1500);
                }
            }
            logCompiler(message, 'info');
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initBlueprintSync, 600);
        });
    </script>
</body>

</html>
